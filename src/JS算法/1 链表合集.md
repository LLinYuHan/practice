# 1. 链表合集

链表定义

```javascript
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}
```

## 1. 合并两个排序链表

合并两个列表，使其保持顺序

递归解法

```javascript
function merge(list1, list2) {
    if (list1 == null) {
        return list2;
    }

    if (list2 == null) {
        return list1;
    }

    if (list1.val <= list2.val) {
        list1.next = merge(list1.next, list2);
        return list1;
    }
    else {
        list2.next = merge(list1, list2.next);
        return list2;
    }
}
```

迭代解法

```javascript
function merge(list1, list2) {
    let head = new ListNode(-1);
    let cur = head;
    while (list1 && list2) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        }
        else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1) {
        cur.next = list1;
    }
    if (list2) {
        cur.next = list2;
    }
    return head.next;
}
```

## 2. 删除链表元素

删除指定值的链表元素，并返回处理后的链表

递归解法

```javascript
var removeElements = function (head, val) {
    if (head === null) {
        return head;
    }
    head.next = removeElements(head.next, val);
    return head.val === val ? head.next : head;
};
```

迭代解法

```javascript
var removeElements = function (head, val) {
    const dummyNode = new ListNode(0);
    dummyNode.next = head;
    let cur = dummyNode;
    while (cur.next !== null) {
        if (cur.next.val === val) {
            cur.next = cur.next.next;
        }
        else {
            cur = cur.next;
        }
    }
    return dummyNode.next;
};
```

## 3. 反转链表

反转链表，返回反转后链表

递归解法

```javascript
/**
 * 递归方法
 * 1. 终止条件 head 为 null 或 head 的 next 节点为 null
 * 2. 逐步断开 head 和 next 的联系
 * 3. 递归调用，使链表越来越短
 * 4. 将 next.next = head 反转链表指向
 * 5. 返回新的 head
 */
function reverseList(head) {
    if (head == null || head.next == null) {
        return head;
    }
    let next = head.next;
    head.next = null;

    let newHead = reverseList(next);
    next.next = head;
    return newHead;
}
```

迭代解法

```javascript
/**
 * 迭代方法
 * 1. 边界条件 head 为 null 或 head 的 next 节点为 null
 * 2. 循环切断联系再链接
 * 3. 返回新的 head
 */
function reverseList(head) {
    if (head == null || head.next == null) {
        return head;
    }

    let newHead = null;

    while (head !== null) {
        let next = head.next;
        head.next = newHead;
        newHead = head;
        head = next;
    }

    return newHead;
}

```

## 4. 反转链表 II
```javacript
```


## 5. 删除有序链表中的重复项
```javascript
function deleteDuplicates(head) {
    if (!head) {
        return head;
    }

    const dummy = new ListNode(0, head);

    let cur = dummy;

    while (cur.next && cur.next.next) {
        if (cur.next.val === cur.next.next.val) {
            const x = cur.next.val;
            while (cur.next && cur.next.val === x) {
                cur.next = cur.next.next;
            }
        }
        else {
            cur = cur.next;
        }
    }

    return dummy.next;
}
```

## 7. 环形链表 II

给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

```javascript
var detectCycle = function(head) {
    if (!head || !head.next) {
        return null;
    }

    let slow = head;
    let fast = head;
    let hasCycle = false;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow === fast) {
            hasCycle = true;
            break;
        }
    }

    if (!hasCycle) {
        return null;
    }

    let start = head;
    while (start !== slow) {
        start = start.next;
        slow = slow.next;
    }

    return start;
};
```

## 8. 随机链表的复制

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

```javascript
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    if (!head) return null;

    // 第一次遍历，在每个节点后面插入新节点
    let current = head;
    while (current) {
        const newNode = new Node(current.val, current.next, null);
        current.next = newNode;
        current = newNode.next;
    }

    // 第二次遍历，设置 random 指针
    current = head;
    while (current) {
        if (current.random) {
            current.next.random = current.random.next;
        }

        current = current.next.next;
    }

    // 第三次遍历，拆分链表
    current = head;
    let newHead = head.next;
    let newCurrent = newHead;

    while (current) {
        current.next = newCurrent.next;
        current = current.next;

        if (current) {
            newCurrent.next = current.next;
            newCurrent = newCurrent.next;
        }
    }

    return newHead;
};

```

